# 题目列表多级缓存规划方案

> **文档版本**: v2.0  
> **创建日期**: 2026-02-03  
> **作者**: JavierChen  
> **对应模块**: `jc-smarteroj-backend-question-service`

---

## 一、方案概述

### 1.1 背景与目标

| 痛点         | 描述                               | 影响                   |
| ------------ | ---------------------------------- | ---------------------- |
| **数据库压力** | 题目列表查询频繁访问 MySQL         | 高并发下数据库成为瓶颈 |
| **响应延迟** | 每次查询都需要 DB 读取 + 对象转换  | 用户体验下降           |
| **热点数据** | 部分热门题目被频繁访问             | 重复计算浪费资源       |

**目标**：构建 **L1 (本地缓存 Caffeine) + L2 (分布式缓存 Redis)** 的多级缓存架构，大幅提升题目列表的查询性能。

### 1.2 核心思路

```
┌─────────────────────────────────────────────────────────────────┐
│                         客户端请求                               │
└──────────────────────────────┬──────────────────────────────────┘
                               ↓
┌─────────────────────────────────────────────────────────────────┐
│                     L1: Caffeine 本地缓存                        │
│  ├─ 命中率: 极高 (最热点数据)                                    │
│  ├─ 延迟: ~1μs (微秒级)                                         │
│  ├─ 容量: 有限 (内存约束)                                        │
│  └─ 特性: 进程内缓存，无网络开销                                  │
└──────────────────────────────┬──────────────────────────────────┘
                               ↓ (L1 Miss)
┌─────────────────────────────────────────────────────────────────┐
│                     L2: Redis 分布式缓存                         │
│  ├─ 命中率: 高 (热门题目 TopN)                                   │
│  ├─ 延迟: ~1-5ms (毫秒级)                                       │
│  ├─ 容量: 较大 (Redis 内存)                                      │
│  └─ 特性: 跨节点共享，自动过期                                    │
└──────────────────────────────┬──────────────────────────────────┘
                               ↓ (L2 Miss)
┌─────────────────────────────────────────────────────────────────┐
│                     数据库 (MySQL)                               │
│  └─ 查询后回填 L2 和 L1                                          │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3 业界热门开源方案对比

> 参考 J2Cache、JetCache、pig4cloud multilevel-cache 等知名开源项目

| 项目                      | GitHub Stars | 核心特性                                    | 适用场景                |
| ------------------------- | ------------ | ------------------------------------------- | ----------------------- |
| **J2Cache** (oschina)     | 7.8k+        | L1(Ehcache/Caffeine)+L2(Redis)，Redis Pub/Sub 广播失效 | 集群环境，高一致性需求  |
| **JetCache** (Alibaba)    | 5.3k+        | 两级缓存+自动刷新+分布式锁+注解驱动         | 阿里技术栈，功能完善    |
| **multilevel-cache** (pig4cloud) | 2k+   | Caffeine+Redis，简洁易用                    | Spring Boot 快速集成    |
| **Layering-cache**        | 1.8k+        | 支持多种 L1/L2 组合，分布式锁防击穿         | 灵活配置，企业级项目    |

### 1.4 大厂开源业务项目缓存实践

> 以下是来自国内外一线大厂的生产级缓存设计，极具参考价值

#### 1.4.1 京东 JD-Hotkey：毫秒级热点探测

**背景**：秒杀场景下，某个热门商品被瞬时海量请求访问，可能压垮 Redis 集群某个分片。

**核心架构**：
```
┌─────────────────────────────────────────────────────────────────┐
│                    JD-Hotkey 架构                                │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐         │
│  │   Client    │───▶│   Worker    │───▶│    etcd     │         │
│  │  (业务服务)  │    │ (热点计算)   │    │ (配置中心)   │         │
│  └─────────────┘    └─────────────┘    └─────────────┘         │
│         │                  │                   │               │
│         │  1. 上报待测Key   │  2. 滑动窗口计算   │  3. 热Key推送  │
│         └─────────────────▶└─────────────────▶│               │
│                                               │               │
│         ┌──────────────────────────────────────┘               │
│         ▼                                                      │
│  ┌─────────────┐                                               │
│  │ JVM 本地缓存 │  ← 热Key直接存入本地 Caffeine，QPS 提升 10x    │
│  └─────────────┘                                               │
└─────────────────────────────────────────────────────────────────┘
```

**核心能力**（京东 618 大促验证）：
| 指标 | 数据 |
|------|------|
| 探测 QPS | 单机 37万 Key/秒 |
| 推送延迟 | 1秒内送达所有客户端 |
| 本地缓存命中 | 占总访问量 50%+ |
| Redis 压力 | 减轻 50%+ |

**对本项目的借鉴**：
- 热点题目探测 → 动态推送到 JVM 本地缓存
- 滑动窗口算法 → 计算题目访问热度
- 集群广播机制 → 热点数据同步

#### 1.4.2 美团 Squirrel：万亿级 KV 存储架构

**架构演进历程**：
```
Memcached (2010) → Redis (2013) → Tair (2014) → Squirrel+Cellar (2017+)
     ↓                ↓              ↓                ↓
  一致性哈希      高可用集群       解决扩容问题      自研深度优化
  扩容数据丢失    仍有数据迁移问题  脑裂+业务影响     秒级故障恢复
```

**Squirrel 核心设计**：
| 特性 | 实现方案 |
|------|----------|
| **数据分布** | 预分片 16384 个 Slot，基于 Redis Cluster 思想优化 |
| **故障恢复** | 秒级自动容灾，无需人工介入 |
| **热 Key 处理** | 本地缓存 + 智能分片迁移 |
| **跨地域复制** | 多数据中心同步，保证就近访问 |

**美团多级缓存实践**：
```java
// 美团 OCTO 服务治理框架中的多级缓存设计
// 1. Data Cache 层：原始数据缓存
// 2. Node Snapshot 层：节点粒度数据
// 3. Ability Manager 层：索引和映射管理

// 本项目可借鉴的分层设计
L1: Caffeine (热点题目详情)
L2: Redis (题目列表 + TopN)
L3: MySQL (持久化存储)
```

#### 1.4.3 阿里巴巴 Sentinel：热点参数限流

**核心机制**（与缓存结合）：
| 功能 | 说明 |
|------|------|
| **热点参数探测** | LRU 算法统计最频繁访问的参数 (如题目ID) |
| **滑动窗口统计** | 实时计算每个热点参数的 QPS |
| **令牌桶限流** | 对热点 Key 进行 QPS 控制 |
| **集群模式** | 支持分布式热点汇总 |

```java
// Sentinel 热点参数限流配置示例
// 可用于保护题目详情接口，防止某道题被恶意刷取
@SentinelResource(value = "getQuestionById", 
    blockHandler = "handleBlock")
public QuestionVO getQuestionById(@RequestParam Long questionId) {
    // 业务逻辑
}

// 配置规则：questionId 参数，QPS 限制 1000
ParamFlowRule rule = new ParamFlowRule("getQuestionById")
    .setParamIdx(0)  // 第一个参数
    .setCount(1000)  // QPS 1000
    .setGrade(RuleConstant.FLOW_GRADE_QPS);
```

**对本项目的借鉴**：
- 热点题目自动探测（基于 LRU）
- 与 Sentinel 限流结合，双重保护
- questionId 粒度的 QPS 控制

#### 1.4.4 Facebook TAO：社交图谱缓存

**架构特点**（亿级读写）：
```
┌─────────────────────────────────────────────────────────────────┐
│                    Facebook TAO                                  │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐         │
│  │ TAO Client  │───▶│ TAO Server  │───▶│   MySQL     │         │
│  │ (本地缓存)   │    │ (分布式缓存) │    │ (持久化)    │         │
│  └─────────────┘    └─────────────┘    └─────────────┘         │
│         │                  │                   │               │
│    版本号比对          Read-Through         Write-Through       │
│    减少传输           按需回填              保证一致性          │
└─────────────────────────────────────────────────────────────────┘
```

**核心设计思想**：
| 策略 | 说明 | 本项目应用 |
|------|------|------------|
| **Read-Through** | 缓存未命中自动从 DB 加载并回填 | 题目详情查询 |
| **Write-Through** | 写操作同时更新缓存和 DB | 题目更新时清理缓存 |
| **Version-based** | 客户端携带版本号，无变化返回 304 | 减少题目列表传输 |
| **Eventually Consistent** | 最终一致性，复制延迟 <1s | 允许短暂不一致 |

#### 1.4.5 字节跳动/抖音：亿级流量多级缓存

**缓存层级架构**：
```
浏览器缓存 → CDN → 本地缓存 → Redis 集群 → 数据库
   ↓         ↓       ↓           ↓           ↓
 静态资源   边缘节点  Caffeine   分布式共享  MySQL/TiDB
 强缓存     就近访问  热点数据   全局数据    最终一致性
```

**抖音推荐系统缓存设计**：
| 层级 | 技术 | 命中率目标 |
|------|------|------------|
| 哈希表缓存 | 进程内 | 极高 |
| 变量缓存 | 线程局部 | 高 |
| 分布式缓存 | Redis 集群 | 中高 |
| **总体命中率** | **多级防御** | **99.9%** |

**防护策略**：
- **缓存穿透**：布隆过滤器 + 空值缓存
- **缓存击穿**：Redis 分布式锁重建
- **缓存雪崩**：随机过期时间 + 熔断降级

#### 1.4.6 携程 Apollo：配置中心缓存设计

**双重缓存机制**（高可用设计）：
```java
// 携程 Apollo 本地缓存策略
// 1. 内存缓存：快速访问
// 2. 文件缓存：服务端故障时降级

// 刷新机制
// - HTTP Long Polling：实时推送（主）
// - 定时拉取（5分钟）：兜底机制（备）

// 对本项目的借鉴：
// 当 Redis 不可用时，降级到本地 Caffeine + 文件缓存
```

**高可用设计**：
| 场景 | 应对策略 |
|------|----------|
| 服务端不可用 | 读取本地文件缓存 |
| 网络分区 | Long Polling 超时后定时拉取补偿 |
| 配置变更 | 广播通知 + 版本校验 |

### 1.5 本方案采用的综合策略

基于以上大厂实践，本方案采用以下综合策略：

| 借鉴来源 | 采用策略 | 应用场景 |
|----------|----------|----------|
| **JD-Hotkey** | 热点题目探测 + JVM 本地缓存推送 | 秒杀式热门题目访问 |
| **美团 Squirrel** | 多级缓存分层 + 智能预热 | 题目列表 + 详情缓存 |
| **阿里 Sentinel** | 热点参数限流 + LRU 探测 | API 接口保护 |
| **Facebook TAO** | Read-Through + 版本比对 | 减少无效传输 |
| **字节抖音** | 随机 TTL + 熔断降级 | 防雪崩 + 高可用 |
| **携程 Apollo** | 双重缓存 + 推拉结合 | 配置 + 降级策略 |
| **J2Cache** | Redis Pub/Sub 广播失效 | 集群 L1 缓存同步 |
| **JetCache** | 注解驱动 + 自动刷新 | 代码简洁性 |

---

## 二、技术选型

### 2.1 缓存框架对比

| 维度        | Caffeine                  | Guava Cache        | Ehcache            | Redis                |
| ----------- | ------------------------- | ------------------ | ------------------ | -------------------- |
| **性能**    | 最优 (Window TinyLFU)     | 较好               | 好                 | 优秀                 |
| **淘汰策略** | LFU + LRU 混合            | LRU                | LRU/LFU/FIFO       | LRU / TTL            |
| **命中率**  | 最高 (业界公认)           | 高                 | 高                 | 高                   |
| **适用场景** | 单机高频热点              | 单机缓存           | 单机/集群          | 分布式共享           |
| **维护成本** | 低                        | 低                 | 中等               | 中等                 |

**最终选型**：
- **L1**: Caffeine（高性能本地缓存，Window TinyLFU 淘汰算法命中率最高）
- **L2**: Redis（已集成 Sa-Token Redis，无需额外引入）

### 2.2 缓存数据结构

#### L1 缓存 (Caffeine)

| 缓存项          | Key 格式                           | Value 类型              | 容量   | 过期策略           |
| --------------- | ---------------------------------- | ----------------------- | ------ | ------------------ |
| **题目详情**    | `question:vo:{questionId}`         | `QuestionVO`            | 500    | 5分钟写入后过期     |
| **热门列表**    | `question:list:hot:{page}:{size}`  | `Page<QuestionVO>`      | 50     | 2分钟写入后过期     |
| **用户做题数**  | `user:submit:count:{userId}`       | `Long`                  | 1000   | 10分钟写入后过期    |

#### L2 缓存 (Redis)

| 缓存项          | Key 格式                           | Value 类型              | 过期时间 | 存储策略           |
| --------------- | ---------------------------------- | ----------------------- | -------- | ------------------ |
| **题目详情**    | `ojq:vo:{questionId}`              | JSON(QuestionVO)        | 30分钟   | 按热度动态调整     |
| **热门列表**    | `ojq:list:hot:{page}:{size}`       | JSON(Page<QuestionVO>)  | 10分钟   | 热门首页优先       |
| **TopN 题目**   | `ojq:topn:questions`               | Redis ZSET              | 1小时    | 用户解题数排名     |
| **用户做题数**  | `oju:submit:count:{userId}`        | String(数字)            | 1小时    | 提交时累加         |
| **缓存锁**      | `ojq:lock:{questionId}`            | String(1)               | 10秒     | 防缓存击穿         |

---

## 三、缓存策略设计

### 3.1 L1 缓存策略 (Caffeine)

#### 3.1.1 最热点数据识别

采用 **访问频率统计 + 主动预热** 的方式识别热点：

```java
// 热点识别维度
public enum HotQuestionMetric {
    VIEW_COUNT,      // 浏览次数
    SUBMIT_COUNT,    // 提交次数
    ACCEPT_RATE,     // 通过率（热门题目通常通过率适中）
    RECENT_ACCESS    // 最近访问时间
}

// 热点评分公式（参考 JetCache 热点Key探测思路）
double hotScore = (viewCount * 0.3) + (submitCount * 0.5) + (recentScore * 0.2);
```

#### 3.1.2 Caffeine 配置

```java
@Configuration
@Slf4j
public class CacheConfig {
    
    /**
     * 题目详情缓存 - 高频单点访问
     * 
     * 参考 JetCache 配置思路：
     * - 使用 Window TinyLFU 淘汰策略（Caffeine 默认）
     * - 开启统计监控命中率
     */
    @Bean("questionVOCache")
    public Cache<Long, QuestionVO> questionVOCache() {
        return Caffeine.newBuilder()
                .maximumSize(500)                          // 最多 500 个题目
                .expireAfterWrite(5, TimeUnit.MINUTES)     // 5分钟过期
                .recordStats()                             // 开启统计
                .removalListener((key, value, cause) -> 
                    log.debug("L1 缓存移除: questionId={}, cause={}", key, cause))
                .build();
    }
    
    /**
     * 热门列表缓存 - 首页/列表页
     */
    @Bean("hotListCache")
    public Cache<String, Page<QuestionVO>> hotListCache() {
        return Caffeine.newBuilder()
                .maximumSize(50)                           // 最多 50 个分页
                .expireAfterWrite(2, TimeUnit.MINUTES)     // 2分钟过期（频繁变化）
                .recordStats()
                .build();
    }
    
    /**
     * 用户做题统计缓存
     */
    @Bean("userSubmitCountCache")
    public Cache<Long, Long> userSubmitCountCache() {
        return Caffeine.newBuilder()
                .maximumSize(1000)                         // 最多 1000 用户
                .expireAfterWrite(10, TimeUnit.MINUTES)    // 10分钟过期
                .build();
    }
}
```

### 3.2 L2 缓存策略 (Redis)

#### 3.2.1 TopN 热门题目维护

> 参考 J2Cache 的定时刷新机制 + JetCache 的 RefreshPolicy

```java
/**
 * TopN 热门题目维护策略
 * 
 * 数据来源: 用户做题数量 → 题目热度排名
 * 更新频率: 每 10 分钟定时任务刷新
 * 存储结构: Redis Sorted Set (ZSET)
 */
@Component
@Slf4j
public class TopNQuestionStrategy {
    
    @Resource
    private QuestionMapper questionMapper;
    
    @Resource
    private StringRedisTemplate redisTemplate;
    
    private static final String TOP_N_KEY = "ojq:topn:questions";
    private static final int TOP_N_SIZE = 100;
    
    /**
     * 计算 TopN 热门题目
     * 基于近 7 天提交量 + 通过率加权
     * 
     * 参考 JetCache RefreshPolicy 思路：定时自动刷新
     */
    @Scheduled(fixedRate = 600000) // 每10分钟
    public void refreshTopNQuestions() {
        try {
            log.info("[TopN] 开始刷新热门题目排名...");
            
            // 1. 查询近 7 天热门题目（按提交量排序）
            List<QuestionHotDTO> hotQuestions = questionMapper.selectTopNBySubmitCount(
                DateUtil.offsetDay(new Date(), -7), TOP_N_SIZE);
            
            if (CollUtil.isEmpty(hotQuestions)) {
                log.warn("[TopN] 无热门题目数据");
                return;
            }
            
            // 2. 计算热度分数
            Map<Long, Double> scoreMap = hotQuestions.stream()
                .collect(Collectors.toMap(
                    QuestionHotDTO::getQuestionId,
                    q -> q.getSubmitCount() * 0.6 + q.getAcceptRate() * 100 * 0.4
                ));
            
            // 3. 使用 Redis Pipeline 批量更新 ZSET（原子操作）
            redisTemplate.executePipelined((RedisCallback<Object>) connection -> {
                byte[] keyBytes = TOP_N_KEY.getBytes();
                connection.del(keyBytes);
                scoreMap.forEach((qid, score) -> 
                    connection.zAdd(keyBytes, score, qid.toString().getBytes()));
                connection.expire(keyBytes, 3600); // 1小时过期
                return null;
            });
            
            log.info("[TopN] 刷新完成，共 {} 道题目", scoreMap.size());
        } catch (Exception e) {
            log.error("[TopN] 刷新失败", e);
        }
    }
    
    /**
     * 获取 TopN 题目ID列表
     */
    public List<Long> getTopNQuestionIds(int n) {
        Set<String> ids = redisTemplate.opsForZSet()
            .reverseRange(TOP_N_KEY, 0, n - 1);
        if (CollUtil.isEmpty(ids)) {
            return Collections.emptyList();
        }
        return ids.stream().map(Long::valueOf).collect(Collectors.toList());
    }
}
```

#### 3.2.2 Redis 缓存键规范

| 前缀     | 含义             | 示例                          |
| -------- | ---------------- | ----------------------------- |
| `ojq:`   | OJ Question      | `ojq:vo:12345`                |
| `oju:`   | OJ User          | `oju:submit:count:67890`      |
| `ojs:`   | OJ Statistics    | `ojs:accept:rate:12345`       |
| `ojl:`   | OJ Lock          | `ojl:question:12345`          |

---

## 四、多级缓存查询流程

### 4.1 题目详情查询 (getQuestionVOById)

> 参考 pig4cloud multilevel-cache 的 lookup 逻辑

```java
@Service
@Slf4j
public class QuestionCacheService {
    
    @Resource
    private Cache<Long, QuestionVO> questionVOCache;       // L1: Caffeine
    
    @Resource
    private StringRedisTemplate redisTemplate;             // L2: Redis
    
    @Resource
    private QuestionService questionService;               // 数据库查询
    
    private static final String REDIS_KEY_PREFIX = "ojq:vo:";
    private static final String LOCK_KEY_PREFIX = "ojl:question:";
    private static final long REDIS_EXPIRE_MINUTES = 30;
    private static final long LOCK_EXPIRE_SECONDS = 10;
    
    /**
     * 多级缓存查询题目详情
     * 
     * 查询顺序: L1 (Caffeine) → L2 (Redis) → DB (MySQL)
     * 
     * 参考 pig4cloud multilevel-cache 实现
     */
    public QuestionVO getQuestionVOById(Long questionId) {
        // 1. 查询 L1 缓存 (Caffeine)
        QuestionVO cachedVO = questionVOCache.getIfPresent(questionId);
        if (cachedVO != null) {
            log.debug("L1 命中: questionId={}", questionId);
            return cachedVO;
        }
        
        // 2. 查询 L2 缓存 (Redis)
        String redisKey = REDIS_KEY_PREFIX + questionId;
        String jsonValue = redisTemplate.opsForValue().get(redisKey);
        if (StrUtil.isNotBlank(jsonValue)) {
            log.debug("L2 命中: questionId={}", questionId);
            QuestionVO voFromRedis = JSONUtil.toBean(jsonValue, QuestionVO.class);
            // 回填 L1
            questionVOCache.put(questionId, voFromRedis);
            return voFromRedis;
        }
        
        // 3. 缓存未命中，查询数据库（带互斥锁防止缓存击穿）
        return loadFromDBWithLock(questionId, redisKey);
    }
    
    /**
     * 带分布式锁的数据库加载
     * 
     * 防止缓存击穿：使用 Redis SETNX 实现互斥锁
     * 参考业界 Cache Stampede Protection 最佳实践
     */
    private QuestionVO loadFromDBWithLock(Long questionId, String redisKey) {
        String lockKey = LOCK_KEY_PREFIX + questionId;
        
        try {
            // 尝试获取分布式锁
            Boolean locked = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, "1", LOCK_EXPIRE_SECONDS, TimeUnit.SECONDS);
            
            if (Boolean.TRUE.equals(locked)) {
                // 获取锁成功，查询数据库
                log.debug("获取锁成功，查询数据库: questionId={}", questionId);
                return loadAndCacheFromDB(questionId, redisKey);
            } else {
                // 获取锁失败，短暂等待后重试 L2
                log.debug("获取锁失败，等待重试: questionId={}", questionId);
                Thread.sleep(50);
                String jsonValue = redisTemplate.opsForValue().get(redisKey);
                if (StrUtil.isNotBlank(jsonValue)) {
                    QuestionVO vo = JSONUtil.toBean(jsonValue, QuestionVO.class);
                    questionVOCache.put(questionId, vo);
                    return vo;
                }
                // 仍未命中，直接查库（降级）
                return loadAndCacheFromDB(questionId, redisKey);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return loadAndCacheFromDB(questionId, redisKey);
        } finally {
            // 释放锁
            redisTemplate.delete(lockKey);
        }
    }
    
    /**
     * 从数据库加载并回填缓存
     */
    private QuestionVO loadAndCacheFromDB(Long questionId, String redisKey) {
        Question question = questionService.getById(questionId);
        if (question == null) {
            // 缓存空值防止穿透（短过期）
            redisTemplate.opsForValue().set(redisKey, "", 1, TimeUnit.MINUTES);
            return null;
        }
        
        QuestionVO voFromDB = questionService.getQuestionVO(question);
        
        // 回填 L1 和 L2
        questionVOCache.put(questionId, voFromDB);
        redisTemplate.opsForValue().set(
            redisKey, 
            JSONUtil.toJsonStr(voFromDB), 
            REDIS_EXPIRE_MINUTES + RandomUtil.randomInt(0, 5), // 随机偏移防雪崩
            TimeUnit.MINUTES
        );
        
        return voFromDB;
    }
}
```

### 4.2 题目列表查询 (listQuestionVOByPage)

```java
/**
 * 题目列表多级缓存查询
 * 
 * 缓存策略（参考 JetCache 热点探测思路）:
 * - 首页热门列表: 缓存（高频访问）
 * - 带筛选条件列表: 不缓存（条件组合太多）
 * - 分页第 1-3 页: 缓存
 * - 分页第 4+ 页: 不缓存（访问频次低）
 */
public Page<QuestionVO> listQuestionVOByPageWithCache(
        QuestionQueryRequest request, HttpServletRequest httpRequest) {
    
    // 判断是否可缓存（无复杂筛选条件 + 前3页）
    if (!isCacheable(request)) {
        return questionService.getQuestionVOPage(
            questionService.page(new Page<>(request.getCurrent(), request.getPageSize()),
                questionService.getQueryWrapper(request)),
            httpRequest);
    }
    
    String cacheKey = buildListCacheKey(request);
    
    // 1. 查询 L1 缓存
    Page<QuestionVO> cachedPage = hotListCache.getIfPresent(cacheKey);
    if (cachedPage != null) {
        log.debug("L1 列表命中: key={}", cacheKey);
        return cachedPage;
    }
    
    // 2. 查询 L2 缓存
    String redisKey = "ojq:list:hot:" + cacheKey;
    String jsonValue = redisTemplate.opsForValue().get(redisKey);
    if (StrUtil.isNotBlank(jsonValue)) {
        log.debug("L2 列表命中: key={}", cacheKey);
        Page<QuestionVO> pageFromRedis = JSONUtil.toBean(jsonValue, 
            new TypeReference<Page<QuestionVO>>() {});
        hotListCache.put(cacheKey, pageFromRedis);
        return pageFromRedis;
    }
    
    // 3. 查询数据库并回填缓存
    Page<QuestionVO> pageFromDB = questionService.getQuestionVOPage(
        questionService.page(new Page<>(request.getCurrent(), request.getPageSize()),
            questionService.getQueryWrapper(request)),
        httpRequest);
    
    // 回填 L1 + L2
    hotListCache.put(cacheKey, pageFromDB);
    redisTemplate.opsForValue().set(
        redisKey, 
        JSONUtil.toJsonStr(pageFromDB), 
        10 + RandomUtil.randomInt(0, 2), // 10-12分钟，随机偏移
        TimeUnit.MINUTES
    );
    
    return pageFromDB;
}

/**
 * 判断请求是否可缓存
 */
private boolean isCacheable(QuestionQueryRequest request) {
    // 无标签筛选 + 无关键词搜索 + 前3页
    return CollUtil.isEmpty(request.getTags()) 
        && StrUtil.isBlank(request.getSearchText())
        && request.getCurrent() <= 3
        && request.getPageSize() <= 20;
}

/**
 * 构建列表缓存 Key
 */
private String buildListCacheKey(QuestionQueryRequest request) {
    return String.format("%d_%d_%s", 
        request.getCurrent(), 
        request.getPageSize(),
        Optional.ofNullable(request.getSortField()).orElse("default"));
}
```

---

## 五、缓存一致性策略

### 5.1 数据更新时缓存失效

> 参考 J2Cache 的 Redis Pub/Sub 广播失效机制

| 操作类型     | 失效策略                      | 实现方式                      |
| ------------ | ----------------------------- | ----------------------------- |
| **题目更新** | 删除 L1 + L2 对应缓存         | 本地失效 + Redis Pub/Sub 广播 |
| **题目删除** | 删除 L1 + L2 对应缓存         | 本地失效 + Redis Pub/Sub 广播 |
| **题目新增** | 不影响（自然加入缓存）        | -                             |
| **提交成功** | 更新用户做题数统计            | 异步累加                      |

```java
/**
 * 缓存失效处理器
 * 
 * 参考 J2Cache 的广播失效机制
 * 使用 Redis Pub/Sub 实现集群节点间的 L1 缓存同步清理
 */
@Component
@Slf4j
public class QuestionCacheInvalidator {
    
    @Resource
    private Cache<Long, QuestionVO> questionVOCache;
    
    @Resource
    private Cache<String, Page<QuestionVO>> hotListCache;
    
    @Resource
    private StringRedisTemplate redisTemplate;
    
    private static final String CACHE_INVALIDATE_CHANNEL = "ojq:cache:invalidate";
    
    /**
     * 题目更新/删除时清理缓存（发布失效消息）
     */
    public void invalidateQuestion(Long questionId) {
        // 清理本地 L1
        questionVOCache.invalidate(questionId);
        
        // 清理 L2
        redisTemplate.delete("ojq:vo:" + questionId);
        
        // 广播失效消息给其他节点
        redisTemplate.convertAndSend(CACHE_INVALIDATE_CHANNEL, 
            "question:" + questionId);
        
        log.info("[CacheInvalidate] 题目缓存已清理: questionId={}", questionId);
    }
    
    /**
     * 批量清理列表缓存（题目变更后）
     */
    public void invalidateListCache() {
        // 清理 L1 热门列表缓存
        hotListCache.invalidateAll();
        
        // 清理 L2 热门列表缓存（使用 SCAN 避免阻塞）
        Set<String> keys = redisTemplate.keys("ojq:list:hot:*");
        if (CollUtil.isNotEmpty(keys)) {
            redisTemplate.delete(keys);
        }
        
        // 广播失效消息
        redisTemplate.convertAndSend(CACHE_INVALIDATE_CHANNEL, "list:all");
        
        log.info("[CacheInvalidate] 列表缓存已清理");
    }
}

/**
 * Redis Pub/Sub 监听器
 * 
 * 接收其他节点的缓存失效消息，清理本地 L1 缓存
 * 参考 J2Cache 的 JGroups/Redis Pub/Sub 机制
 */
@Component
@Slf4j
public class CacheInvalidateListener {
    
    @Resource
    private Cache<Long, QuestionVO> questionVOCache;
    
    @Resource
    private Cache<String, Page<QuestionVO>> hotListCache;
    
    @Bean
    public RedisMessageListenerContainer redisMessageListenerContainer(
            RedisConnectionFactory connectionFactory) {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        container.addMessageListener((message, pattern) -> {
            String msg = new String(message.getBody());
            handleInvalidateMessage(msg);
        }, new ChannelTopic("ojq:cache:invalidate"));
        return container;
    }
    
    private void handleInvalidateMessage(String message) {
        log.debug("[CacheListener] 收到失效消息: {}", message);
        
        if (message.startsWith("question:")) {
            Long questionId = Long.valueOf(message.substring("question:".length()));
            questionVOCache.invalidate(questionId);
        } else if ("list:all".equals(message)) {
            hotListCache.invalidateAll();
        }
    }
}
```

### 5.2 缓存预热

> 参考业界 Cache Warming 最佳实践

```java
/**
 * 服务启动时缓存预热
 * 
 * 参考业界最佳实践：
 * - 预热 TopN 热门数据
 * - 预热首页常访问数据
 * - 异步预热避免阻塞启动
 */
@Component
@Slf4j
public class CacheWarmer implements ApplicationRunner {
    
    @Resource
    private TopNQuestionStrategy topNQuestionStrategy;
    
    @Resource
    private QuestionCacheService questionCacheService;
    
    @Resource
    private ThreadPoolTaskExecutor cacheWarmExecutor;
    
    @Override
    public void run(ApplicationArguments args) {
        log.info("[CacheWarmer] 开始缓存预热...");
        
        // 异步预热，避免阻塞服务启动
        CompletableFuture.runAsync(() -> {
            try {
                warmupCache();
            } catch (Exception e) {
                log.error("[CacheWarmer] 预热失败", e);
            }
        }, cacheWarmExecutor);
    }
    
    private void warmupCache() {
        long startTime = System.currentTimeMillis();
        
        // 1. 预热 TopN 热门题目排名
        topNQuestionStrategy.refreshTopNQuestions();
        
        // 2. 预热首页题目列表（前3页）
        for (int page = 1; page <= 3; page++) {
            QuestionQueryRequest request = new QuestionQueryRequest();
            request.setCurrent(page);
            request.setPageSize(20);
            questionCacheService.listQuestionVOByPageWithCache(request, null);
        }
        
        // 3. 预热 Top50 热门题目详情
        List<Long> topIds = topNQuestionStrategy.getTopNQuestionIds(50);
        for (Long qid : topIds) {
            questionCacheService.getQuestionVOById(qid);
        }
        
        long costTime = System.currentTimeMillis() - startTime;
        log.info("[CacheWarmer] 预热完成，共加载 {} 道题目，耗时 {}ms", 
            topIds.size(), costTime);
    }
}
```

---

## 六、缓存防护策略

> 参考业界 Cache Stampede Protection 最佳实践

### 6.1 缓存穿透防护

| 问题         | 原因                     | 解决方案                       |
| ------------ | ------------------------ | ------------------------------ |
| 缓存穿透     | 查询不存在的数据         | 空值缓存（1分钟过期）          |
| 恶意攻击     | 大量不存在的 ID          | 布隆过滤器预校验               |

```java
/**
 * 布隆过滤器预校验（可选增强）
 */
@Component
public class QuestionBloomFilter {
    
    private BloomFilter<Long> bloomFilter;
    
    @PostConstruct
    public void init() {
        // 预期 10000 道题目，误判率 0.01%
        bloomFilter = BloomFilter.create(
            Funnels.longFunnel(), 10000, 0.0001);
        
        // 加载所有题目 ID
        List<Long> allIds = questionMapper.selectAllIds();
        allIds.forEach(bloomFilter::put);
    }
    
    public boolean mightContain(Long questionId) {
        return bloomFilter.mightContain(questionId);
    }
}
```

### 6.2 缓存击穿防护

| 问题         | 原因                     | 解决方案                       |
| ------------ | ------------------------ | ------------------------------ |
| 缓存击穿     | 热点数据过期瞬间大量请求 | 互斥锁 + 逻辑过期              |
| 并发重建     | 多个请求同时查库         | Redis SETNX 分布式锁           |

> 已在上文 `loadFromDBWithLock` 方法中实现

### 6.3 缓存雪崩防护

| 问题         | 原因                     | 解决方案                       |
| ------------ | ------------------------ | ------------------------------ |
| 缓存雪崩     | 大量缓存同时过期         | 过期时间随机化                 |
| Redis 宕机   | 分布式缓存不可用         | 多级缓存兜底 + 熔断降级        |

```java
// 过期时间添加随机偏移，防止同时过期
long expireMinutes = REDIS_EXPIRE_MINUTES + RandomUtil.randomInt(0, 5);
```

---

## 七、依赖配置

### 7.1 Maven 依赖 (pom.xml)

在 `jc-smarteroj-backend-question-service/pom.xml` 添加：

```xml
<!-- Caffeine 高性能本地缓存 -->
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
    <version>2.9.3</version>
</dependency>

<!-- Spring Boot Cache (可选，用于 @Cacheable 注解) -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

<!-- Guava (布隆过滤器，可选) -->
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>32.1.2-jre</version>
</dependency>
```

### 7.2 配置项 (application.yml)

```yaml
# 多级缓存配置
cache:
  question:
    # L1 Caffeine 配置
    caffeine:
      question-vo:
        maximum-size: 500
        expire-after-write: 5m
      hot-list:
        maximum-size: 50
        expire-after-write: 2m
    # L2 Redis 配置
    redis:
      key-prefix: "ojq:"
      question-vo-expire: 30m
      hot-list-expire: 10m
      top-n-expire: 1h
    # 防护策略
    protection:
      lock-expire: 10s
      null-value-expire: 1m
      ttl-random-offset: 5m
```

---

## 八、监控与统计

### 8.1 缓存命中率监控

```java
@RestController
@RequestMapping("/admin/cache")
public class CacheStatsController {
    
    @Resource
    private Cache<Long, QuestionVO> questionVOCache;
    
    @GetMapping("/stats")
    public CacheStatsVO getCacheStats() {
        CacheStats caffeineStats = questionVOCache.stats();
        
        return CacheStatsVO.builder()
            // L1 统计
            .l1HitRate(String.format("%.2f%%", caffeineStats.hitRate() * 100))
            .l1HitCount(caffeineStats.hitCount())
            .l1MissCount(caffeineStats.missCount())
            .l1EvictionCount(caffeineStats.evictionCount())
            .l1LoadSuccessCount(caffeineStats.loadSuccessCount())
            .l1AverageLoadPenalty(caffeineStats.averageLoadPenalty() / 1_000_000 + "ms")
            // L2 统计（手动统计）
            .l2HitRate(calculateRedisHitRate())
            .topNRefreshTime(getLastRefreshTime())
            .build();
    }
}
```

### 8.2 预警阈值

| 指标               | 正常范围       | 告警阈值      | 处理措施               |
| ------------------ | -------------- | ------------- | ---------------------- |
| L1 命中率          | ≥ 80%          | < 60%         | 检查容量/过期配置      |
| L2 命中率          | ≥ 70%          | < 50%         | 检查 TopN 策略         |
| 缓存淘汰频率       | 稳定           | 突增          | 增加容量或调整策略     |
| Redis 内存使用     | < 70%          | ≥ 80%         | 清理或扩容             |
| 平均加载时间       | < 50ms         | > 100ms       | 检查数据库性能         |

---

## 九、实施计划

| 阶段 | 内容                               | 工期   | 优先级 |
| ---- | ---------------------------------- | ------ | ------ |
| 1    | 引入 Caffeine 依赖 + 基础配置      | 0.5天  | P0     |
| 2    | 实现题目详情多级缓存查询           | 1天    | P0     |
| 3    | 实现题目列表多级缓存查询           | 1天    | P0     |
| 4    | TopN 热门题目策略 + 定时任务       | 0.5天  | P1     |
| 5    | 缓存失效处理 + Redis Pub/Sub 广播  | 0.5天  | P1     |
| 6    | 缓存预热 + 启动优化                | 0.5天  | P2     |
| 7    | 防护策略（穿透/击穿/雪崩）         | 0.5天  | P2     |
| 8    | 监控统计 + 管理接口                | 0.5天  | P2     |

**总工期**: 约 5-6 天

---

## 十、预期收益

| 指标               | 优化前          | 优化后 (预期)    | 提升       |
| ------------------ | --------------- | ---------------- | ---------- |
| 题目详情响应时间   | ~50ms           | ~5ms (L1)        | **90%↓**   |
| 题目列表响应时间   | ~100ms          | ~10ms (L1)       | **90%↓**   |
| 数据库 QPS         | 高              | 降低 70%+        | **70%↓**   |
| 服务吞吐量         | 27 QPS (列表)   | 200+ QPS         | **7x↑**    |
| 缓存命中率 (L1)    | -               | ≥ 80%            | -          |
| 缓存命中率 (L2)    | -               | ≥ 70%            | -          |

---

## 十一、风险与应对

| 风险                 | 影响   | 概率   | 应对措施                               |
| -------------------- | ------ | ------ | -------------------------------------- |
| 缓存穿透             | 高     | 低     | 空值缓存 + 布隆过滤器                  |
| 缓存击穿             | 高     | 中     | 互斥锁 + 逻辑过期                      |
| 缓存雪崩             | 高     | 低     | 过期时间随机化 + 多级缓存兜底          |
| 数据不一致           | 中     | 中     | 短过期 + Redis Pub/Sub 广播失效        |
| 内存溢出 (Caffeine)  | 高     | 低     | 限制容量 + 监控告警                    |
| 集群同步延迟         | 中     | 低     | Redis Pub/Sub + 最终一致性             |

---

## 十二、参考资料

### 12.1 开源缓存框架

| 项目/文档                                  | 说明                           |
| ------------------------------------------ | ------------------------------ |
| [J2Cache](https://gitee.com/ld/J2Cache)    | 两级缓存框架，广播失效机制     |
| [JetCache](https://github.com/alibaba/jetcache) | 阿里两级缓存，自动刷新策略 |
| [pig4cloud multilevel-cache](https://github.com/pig-mesh/multilevel-cache-spring-boot-starter) | Spring Boot 多级缓存 Starter |
| [Caffeine Wiki](https://github.com/ben-manes/caffeine/wiki) | Caffeine 官方文档       |
| [Cache-Aside Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside) | 微软缓存模式最佳实践 |

### 12.2 大厂开源项目

| 项目/文档                                  | 公司   | 说明                           |
| ------------------------------------------ | ------ | ------------------------------ |
| [JD-Hotkey](https://gitee.com/jd-platform-opensource/hotkey) | 京东 | 毫秒级热点 Key 探测框架 |
| [Sentinel](https://github.com/alibaba/Sentinel) | 阿里 | 流量控制 + 热点参数限流 |
| [Apollo](https://github.com/apolloconfig/apollo) | 携程 | 配置中心，双重缓存设计 |
| [Kratos](https://github.com/go-kratos/kratos) | B站 | Go 微服务框架，Cache-Aside 模式 |
| [OCTO](https://github.com/Meituan-Dianping/octo-rpc) | 美团 | 服务治理框架，多级缓存 |

### 12.3 技术博客 & 论文

| 文章                                       | 来源   | 核心内容                       |
| ------------------------------------------ | ------ | ------------------------------ |
| [美团万亿级 KV 存储架构](https://tech.meituan.com/2020/07/01/kv-squirrel-cellar.html) | 美团技术团队 | Squirrel + Cellar 架构演进 |
| [TAO: Facebook's Distributed Data Store](https://www.usenix.org/conference/atc13/technical-sessions/presentation/bronson) | Facebook | 社交图谱分布式缓存论文 |
| [Redis 最佳实践](https://github.com/aliyun/alibabacloud-redis-training-demo) | 阿里云 | Redis 高并发实战、分布式锁 |
| [抖音多级缓存架构](https://juejin.cn/post/7300000000000000000) | 字节跳动 | 亿级流量缓存设计 |

---

> **注意**: 本文档为规划阶段产出物，具体实现时需根据实际压测结果调整参数。

